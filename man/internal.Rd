% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JaBbA.R, R/Rcplex.R
\name{jabba_stub}
\alias{jabba_stub}
\alias{karyograph}
\alias{karyograph_stub}
\alias{.plot_ppfit}
\alias{.ramip_stub}
\alias{ramip_stub}
\alias{jmessage}
\alias{.correct.slack}
\alias{vaggregate}
\alias{write.tab}
\alias{karyograph}
\alias{read_vcf}
\alias{levapply}
\alias{Rcplex2}
\title{jabba_stub}
\usage{
jabba_stub(junctions, coverage, seg = NULL, cfield = NULL, tfield = NULL,
  nudge.balanced = FALSE, thresh.balanced = 500, outdir = "./",
  nseg = NULL, hets = NULL, name = "tumor", mc.cores = 1,
  max.threads = Inf, max.mem = 16, purity = NA, ploidy = NA,
  strict = FALSE, mipstart = NULL, field = "ratio", subsample = NULL,
  tilim = 1200, mem = 16, init = NULL, edgenudge = 0.1,
  slack.penalty = 100, use.gurobi = FALSE, overwrite = FALSE,
  verbose = TRUE)

karyograph_stub(seg.file, cov.file, nseg.file = NULL, het.file = NULL,
  ra = NULL, junction.file = NULL, out.file, use.ppurple = TRUE,
  ra.file = NULL, verbose = FALSE, force.seqlengths = NULL, purity = NA,
  ploidy = NA, field = "ratio", mc.cores = 1, max.chunk = 1e+08,
  subsample = NULL)

.plot_ppfit(kag, xlim = c(-Inf, Inf))

ramip_stub(kag.file, out.file, mc.cores = 1, max.threads = Inf, mem = 16,
  tilim = 1200, slack.prior = 0.001, gamma = NA, beta = NA,
  customparams = TRUE, purity.min = NA, purity.max = NA,
  ploidy.min = NA, ploidy.max = NA, init = NULL, mipstart = NULL,
  use.gurobi = FALSE, verbose = FALSE, edge.nudge = 0, ab.force = NULL,
  ab.exclude = NULL)

jmessage(..., pre = "JaBbA")

.correct.slack(ra.sol)

vaggregate(...)

write.tab(x, ..., sep = "\\t", quote = FALSE, row.names = FALSE)

karyograph(junctions, tile = NULL, label.edges = FALSE)

read_vcf(fn, gr = NULL, hg = "hg19", geno = NULL, swap.header = NULL,
  verbose = FALSE, add.path = FALSE, tmp.dir = "~/temp/.tmpvcf", ...)

levapply(x, by, FUN = "order")

Rcplex2(cvec, Amat, bvec, Qmat = NULL, lb = 0, ub = Inf,
  control = list(), objsense = c("min", "max"), sense = "L",
  vtype = NULL, n = 1)
}
\arguments{
\item{junctions}{GRangesList of junctions  (i.e. bp pairs with strands oriented AWAY from break) OR path to junction VCF file (BND format), dRanger txt file or rds of GRangesList}

\item{coverage}{GRanges of coverage OR path to cov file, rds of GRanges or .wig / .bed file of (normalized, GC corrected) fragment density}

\item{seg}{optional path to existing segmentation, if missing then we will segment coverage using DNACopy with standard settings}

\item{cfield}{character, junction confidence meta data field in ra}

\item{tfield}{character, tier confidence meta data field in ra}

\item{outdir}{out directory to dump into, default ./}

\item{nseg}{optional path to normal seg file with $cn meta data field}

\item{hets}{optional path to hets.file which is tab delimited text file with fields seqnames, start, end, alt.count.t, ref.count.t, alt.count.n, ref.count.n}

\item{name}{prefix for sample name to be output to seg file}

\item{mc.cores}{number of cores to use (default 1)}

\item{field}{field of coverage GRanges to use as fragment density signal (only relevant if coverage is GRanges rds file)}

\item{subsample}{numeric between 0 and 1 specifying how much to sub-sample high confidence coverage data}

\item{tilim}{timeout for jbaMIP computation (default 1200 seconds)}

\item{init}{jabba object (list) or path to .rds file containing previous jabba object which to use to initialize solution, this object needs to have the identical aberrant junctions as the current jabba object (but may have different segments and loose ends, i.e. is from a previous iteration)}

\item{edgenudge}{numeric hyper-parameter of how much to nudge or reward aberrant junction incorporation, default 0.1 (should be several orders of magnitude lower than average 1/sd on individual segments), a nonzero value encourages incorporation of perfectly balanced rearrangements which would be equivalently optimal with 0 copies or more copies.}

\item{slack.penalty}{penalty to put on every loose.end copy, should be calibrated with respect to 1/(k*sd)^2 for each segment, i.e. that we are comfortable with junction balance constraints introducing k copy number deviation from a segments MLE copy number assignment (the assignment in the absence of junction balance constraints)}

\item{use.gurobi}{logical flag whether to use gurobi vs CPLEX}

\item{overwrite}{flag whether to overwrite existing output directory contents or just continue with existing files.}

\item{...}{arguments to aggregate}

\item{x}{input vector of data}

\item{tile}{GRanges optional existing tiling of the genome (eg a copy number segmentation) from which additional segments will be created}

\item{by}{length(x) vector of categorical labels}

\item{FUN}{function that takes a length k vector and outputs a length k vector, used for processing each "level" of by}

\item{nseg}{path to data.frame or GRanges rds of normal seg file with coordinates and $cn data field specifying germline integer copy number}

\item{junctions}{GRangesList of junctions, where each item is a length GRanges of signed locations}
}
\value{
named vector indexed by levels of "by"

a list with the following fields
$tile = GRanges of length 2*n tiling of the genome corresponding to union of rearrangement breakpoints and copy number endpoints
$G = igraph object representing karyograph, here are the edge and vertex features
     vertex features: $chrom, $start, $end, $width, $strand, $size, $shape, $border.width, $label, $chrom.ord, $y, $col, $weight
     edge features:$ $bp.id, $weight, $from, $to, $col, $type, $line.style, $arrow.shape, $width,
     important:  $type specifies which edges are "aberrant" and "reference", $bp.id specifies which input rearrangement (item in junctions)
     a given aberrant edge came from (and is NA for reference edges)
$adj = 2n x 2n adjacency matrix whose nonzero entries ij show the edge.id in $G
$ab.adj = 2n x 2n binary matrix specifying aberrant edges
$ab.edges = length(junctions) x {'from', 'to'} x {'+', '-'} mapping junction id's (indices into input junctions lists) to source and sink vertices,
            in both orientations
mimielinski Sunday, Aug 06, 2017 06:46:15 PM
fix added to handle strange [0 0] junctions outputted
by Snowman ... which failed to match to any tile
todo: may want to also handle junctions that
fall off the other side of the chromosome

length(x) vector of outputs, the results of applying FUN to each "by" defined level of x
}
\description{
Internal function to run single iteration of JaBbA

Generates the following files in the output directory:

karyograph.rds --- file of unpopulated karyograph as an RDS file of a list object storing the output of karyograph


jabba.rds --- file storing JaBbA object

jabba.simple.rds --- file storing JaBbA object simplified so that segments containing all unpopulated aberrant junctions are merged

jabba.raw.rds --- storing raw jbaMIP solution, this may be useful for debugging and QC

jabba.png, jabba.simple.png --- gTrack images of the above reconstructions

jabba.seg.txt --- tsv file with jabba.simple solution segments

jabba.seg.rds --- GRanges rds with jabba.simple solution segments

jabba.adj.txt --- tsv file with edges (i.e. node pairs) of adjacency matrix populated with inferred copy numbers and node ids indexing segments in jabba.seg.txt

jabba.vcf, jabba.simple.vcf --- BND-style vcf output of junctions in JaBbA output populated with rearrangement and interval copy numbers

jabba.cnv.vcf, jabba.simple.cnv.vcf --- cfopy number style VCF showing jabba copy number output

karyograph

run ramip

same as aggregate except returns named vector
with names as first column of output and values as second

Note: there is no need to ever use aggregate or vaggregate, just switch to data.table

Wrapper around variantAnnotation reads VCF into granges or data.table format

Applies FUN locally to levels of x and returns vector of length()
(eg can do a "local" order within levels)

Modification of Rcplex which takes in mipcontrol parameters.
}
\details{
Builds graph from rearrangement breakpoints +/- copy number endpoints
used for downstream jbaMIP and karyoMIP functions

Input bpp is a GRangesList of signed locus pairs describing aberrant adjacencies.
The convention is as follows: Each locus in the input breakpoint pair points to the direction that
is being joined by the adjacencies i.e.
(-) bp points to "left" or preceding segment
(+) bp points to the  "right" or the following segment

eg imagine a|bp1|b
           c|bp2|d
 "+" bp point to the right (eg b or d), "-" bp point to the left (a or c)

Input "tile" is a set of intervals whose endpoints are also used to partition the genome prior to the building of the
karyograph.

Output karyograph connects signed genomic intervals (in a signed tiling of the reference genome) with "aberrant" and "reference" edges.
Reference edges connect intervals that are adjacent in the reference genome, and aberrant edges are inferred (upstream
of this) through cancer genome paired end analysis.
Note that every node, edge, and path in this karyograph has a "reciprocal path"
}
\author{
Marcin Imielinski

Marcin Imielinski

Marcin Imielinski
}
