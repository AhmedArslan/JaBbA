% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JaBbA.R, R/Rcplex.R
\name{jabba_stub}
\alias{jabba_stub}
\alias{karyograph}
\alias{karyograph_stub}
\alias{.plot_ppfit}
\alias{.ramip_stub}
\alias{ramip_stub}
\alias{jmessage}
\alias{vaggregate}
\alias{write.tab}
\alias{read.junctions}
\alias{read_vcf}
\alias{levapply}
\alias{which.indel}
\alias{sv.size}
\alias{reciprocal.cycles}
\alias{Rcplex2}
\title{jabba_stub}
\usage{
jabba_stub(junctions, coverage, seg = NULL, cfield = NULL, tfield = NULL,
  nudge.balanced = FALSE, thresh.balanced = 500, outdir = "./",
  nseg = NULL, hets = NULL, name = "tumor", mc.cores = 1,
  max.threads = Inf, max.mem = 16, purity = NA, ploidy = NA,
  strict = FALSE, mipstart = NULL, field = "ratio", subsample = NULL,
  tilim = 1200, init = NULL, edgenudge = 0.1, slack.penalty = 100,
  use.gurobi = FALSE, indel = TRUE, overwrite = F, verbose = TRUE)

karyograph_stub(seg.file, cov.file, nseg.file = NULL, het.file = NULL,
  ra = NULL, junction.file = NULL, out.file, use.ppurple = TRUE,
  ra.file = NULL, verbose = FALSE, force.seqlengths = NULL, purity = NA,
  ploidy = NA, field = "ratio", mc.cores = 1, max.chunk = 1e+08,
  subsample = NULL)

.plot_ppfit(kag, xlim = c(-Inf, Inf))

ramip_stub(kag.file, out.file, mc.cores = 1, max.threads = Inf, mem = 16,
  tilim = 1200, slack.prior = 0.001, gamma = NA, beta = NA,
  customparams = T, purity.min = NA, purity.max = NA, ploidy.min = NA,
  ploidy.max = NA, init = NULL, mipstart = NULL, use.gurobi = FALSE,
  verbose = FALSE, edge.nudge = 0, ab.force = NULL, ab.exclude = NULL)

jmessage(..., pre = "JaBbA")

vaggregate(...)

write.tab(x, ..., sep = "\\t", quote = F, row.names = F)

read.junctions(rafile, keep.features = T, seqlengths = hg_seqlengths(),
  chr.convert = T, snowman = FALSE, swap.header = NULL,
  breakpointer = FALSE, seqlevels = NULL, force.bnd = FALSE, skip = NA,
  get.loose = FALSE)

read_vcf(fn, gr = NULL, hg = "hg19", geno = NULL, swap.header = NULL,
  verbose = FALSE, add.path = FALSE, tmp.dir = "~/temp/.tmpvcf", ...)

levapply(x, by, FUN = "order")

which.indel(juncs, max.size = 10000)

sv.size(juncs, ...)

reciprocal.cycles(juncs, thresh = 1000, mc.cores = 1, verbose = FALSE,
  chunksize = 1000)

Rcplex2(cvec, Amat, bvec, Qmat = NULL, lb = 0, ub = Inf,
  control = list(), objsense = c("min", "max"), sense = "L",
  vtype = NULL, n = 1)
}
\arguments{
\item{junctions}{GRangesList of junctions  (i.e. bp pairs with strands oriented AWAY from break) OR path to junction VCF file (BND format), dRanger txt file or rds of GRangesList}

\item{coverage}{GRanges of coverage OR path to cov file, rds of GRanges or .wig / .bed file of (normalized, GC corrected) fragment density}

\item{seg}{optional path to existing segmentation, if missing then we will segment coverage using DNACopy with standard settings}

\item{cfield}{character, junction confidence meta data field in ra}

\item{tfield}{character, tier confidence meta data field in ra}

\item{outdir}{out directory to dump into, default ./}

\item{nseg}{optional path to normal seg file with $cn meta data field}

\item{hets}{optional path to hets.file which is tab delimited text file with fields seqnames, start, end, alt.count.t, ref.count.t, alt.count.n, ref.count.n}

\item{name}{prefix for sample name to be output to seg file}

\item{mc.cores}{number of cores to use (default 1)}

\item{field}{field of coverage GRanges to use as fragment density signal (only relevant if coverage is GRanges rds file)}

\item{subsample}{numeric between 0 and 1 specifying how much to sub-sample high confidence coverage data}

\item{tilim}{timeout for jbaMIP computation (default 1200 seconds)}

\item{init}{jabba object (list) or path to .rds file containing previous jabba object which to use to initialize solution, this object needs to have the identical aberrant junctions as the current jabba object (but may have different segments and loose ends, i.e. is from a previous iteration)}

\item{edgenudge}{numeric hyper-parameter of how much to nudge or reward aberrant junction incorporation, default 0.1 (should be several orders of magnitude lower than average 1/sd on individual segments), a nonzero value encourages incorporation of perfectly balanced rearrangements which would be equivalently optimal with 0 copies or more copies.}

\item{slack.penalty}{penalty to put on every loose.end copy, should be calibrated with respect to 1/(k*sd)^2 for each segment, i.e. that we are comfortable with junction balance constraints introducing k copy number deviation from a segments MLE copy number assignment (the assignment in the absence of junction balance constraints)}

\item{use.gurobi}{logical flag whether to use gurobi vs CPLEX}

\item{overwrite}{flag whether to overwrite existing output directory contents or just continue with existing files.}

\item{...}{arguments to aggregate}

\item{x}{input vector of data}

\item{by}{length(x) vector of categorical labels}

\item{FUN}{function that takes a length k vector and outputs a length k vector, used for processing each "level" of by}

\item{juncs}{GRangesList of junctions}

\item{max.size}{the size cutoff in bp, any pair of breakpoints below this
with the correct orintation wil be called}

\item{nseg}{path to data.frame or GRanges rds of normal seg file with coordinates and $cn data field specifying germline integer copy number}

\item{juncs}{GRangesList of junctions}

\item{mc.cores}{parallel}

\item{ignore.strand}{usually TRUE}

\item{juncs}{GRangesList of junctions}

\item{mc.cores}{parallel}

\item{ignore.strand}{usually TRUE}
}
\value{
named vector indexed by levels of "by"

length(x) vector of outputs, the results of applying FUN to each "by" defined level of x

indices of the identified junctions

numerical vector of the same length, Inf means they r not facing each other

numerical vector of the same length, Inf means they r not facing each other
}
\description{
Internal function to run single iteration of JaBbA

Generates the following files in the output directory:

karyograph.rds --- file of unpopulated karyograph as an RDS file of a list object storing the output of karyograph


jabba.rds --- file storing JaBbA object

jabba.simple.rds --- file storing JaBbA object simplified so that segments containing all unpopulated aberrant junctions are merged

jabba.raw.rds --- storing raw jbaMIP solution, this may be useful for debugging and QC

jabba.png, jabba.simple.png --- gTrack images of the above reconstructions

jabba.seg.txt --- tsv file with jabba.simple solution segments

jabba.seg.rds --- GRanges rds with jabba.simple solution segments

jabba.adj.txt --- tsv file with edges (i.e. node pairs) of adjacency matrix populated with inferred copy numbers and node ids indexing segments in jabba.seg.txt

jabba.vcf, jabba.simple.vcf --- BND-style vcf output of junctions in JaBbA output populated with rearrangement and interval copy numbers

jabba.cnv.vcf, jabba.simple.cnv.vcf --- cfopy number style VCF showing jabba copy number output

karyograph

run ramip

same as aggregate except returns named vector
with names as first column of output and values as second

Note: there is no need to ever use aggregate or vaggregate, just switch to data.table

read.junctions

takes in either file or data frame from various formats including BND VCF, bedpe, and others, and returns GRangesList of junctions
and returns junctions in VCF format.

The default output is GRangesList each with a length two GRanges whose strands point AWAY from the break.  If get.loose = TRUE (only relevant for VCF)

wrapper around variantAnnotation reads VCF into granges or data.table format

Applies FUN locally to levels of x and returns vector of length()
(eg can do a "local" order within levels)

Among a GRangesList of junction set, find the indices of isolated, small scale tDup or DEL
They are in the grey area from SV to INDEL.

Simply the distance between pairs of breakpoints

Returns indices (subset of 1:length(junc) corresponding to cycles of (quasi) reciprocal cycles

Modification of Rcplex which takes in mipcontrol parameters.
}
\author{
Marcin Imielinski

Marcin Imielinski

Marcin Imielinski
}
