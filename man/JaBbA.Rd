% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JaBbA.R
\name{JaBbA}
\alias{JaBbA}
\title{JaBbA}
\usage{
JaBbA(junctions, coverage, seg = NULL, outdir = "./JaBbA", cfield = NULL,
  tfield = NULL, nudge.balanced = FALSE, thresh.balanced = 500,
  nseg = NULL, hets = NULL, name = "tumor", purity = NA, ploidy = NA,
  field = "ratio", subsample = NULL, tilim = 1200, mem = 16,
  reiterate = 0, rescue.window = 10000, init = NULL, edgenudge = 0.1,
  use.gurobi = FALSE, slack.penalty = 100, overwrite = FALSE,
  mc.cores = 1, strict = FALSE, max.threads = Inf, max.mem = 16,
  verbose = TRUE)
}
\arguments{
\item{junctions}{GRangesList of junctions  (i.e. bp pairs with strands oriented AWAY from break) OR path to junction VCF file (BND format), dRanger txt file or rds of GRangesList}

\item{coverage}{GRanges of coverage OR path to tsv of cov file w GRanges style columns, rds of GRanges or .wig / .bed file of (+/- normalized, GC corrected) fragment density}

\item{seg}{optional path to existing segmentation, if missing then will segment coverage using DNACopy with standard settings}

\item{outdir}{out directory to dump into, default ./}

\item{cfield}{character, junction confidence meta data field in ra}

\item{tfield}{character, tier confidence meta data field in ra}

\item{nseg}{optional path to normal seg file with $cn meta data field}

\item{hets}{optional path to hets.file which is tab delimited text file with fields seqnames, start, end, alt.count.t, ref.count.t, alt.count.n, ref.count.n}

\item{name}{prefix for sample name to be output to seg file}

\item{field}{field of coverage GRanges to use as fragment density signal (only relevant if coverage is GRanges rds file)}

\item{subsample}{numeric between 0 and 1 specifying fraction with which to  sub-sample high confidence coverage data}

\item{tilim}{integer scalar timeout in seconds for jbaMIP computation (default 1200 seconds)}

\item{mem}{numeric scalar max memory in GB for MIP portion of algorithm (default 16)}

\item{reiterate}{integer scalar specifying how many (re-)iterations of jabba to do, rescuing lower tier junctions that are near loose ends (requires junctions to be tiered via a grangeslist or VCF metadata field $tfield), tiers are 1 = must use, 2 = may use, 3 = use only in iteration>1 if near loose end}

\item{rescue.window}{integer scalar bp window around which to rescue lower tier junctions}

\item{init}{jabba object (list) or path to .rds file containing previous jabba object which to use to initialize solution, this object needs to have the identical aberrant junctions as the current jabba object (but may have different segments and loose ends, i.e. is from a previous iteration)}

\item{edgenudge}{numeric hyper-parameter of how much to nudge or reward aberrant junction incorporation, default 0.1 (should be several orders of magnitude lower than average 1/sd on individual segments), a nonzero value encourages incorporation of perfectly balanced rearrangements which would be equivalently optimal with 0 copies or more copies.}

\item{use.gurobi}{logical flag specifying whether to use gurobi (if TRUE) instead of CPLEX (if FALSE) .. up to user to make sure the respective package is already installed}

\item{slack.penalty}{penalty to put on every loose.end copy, should be calibrated with respect to 1/(k*sd)^2 for each segment, i.e. that we are comfortable with junction balance constraints introducing k copy number deviation from a segments MLE copy number assignment (the assignment in the absence of junction balance constraints)}

\item{overwrite}{logical flag whether to overwrite existing output directory contents or just continue with existing files.}

\item{mc.cores}{integer how many cores to use to fork subgraphs generation (default = 1)}

\item{strict}{logical flag specifying whether to only include junctions that exactly overlap segs}

\item{cores}{number of cores to use (default 1)}

\item{nseg}{path to data.frame or GRanges rds of normal seg file with coordinates and $cn data field specifying germline integer copy number}
}
\value{
gGraph (gGnome package) of balanced rearrangement graph
}
\description{
Module to run jbaMIP + preprocessing from text file or rds input and dump files out to text.

Generates the following files in the output directory:

karyograph.rds --- file of unpopulated karyograph as an RDS file of a list object storing the output of karyograph


jabba.rds --- file storing JaBbA object

jabba.simple.rds --- file storing JaBbA object simplified so that segments containing all unpopulated aberrant junctions are merged

jabba.raw.rds --- storing raw jbaMIP solution, this may be useful for debugging and QC

jabba.png, jabba.simple.png --- gTrack images of the above reconstructions

jabba.seg.txt --- tsv file with jabba.simple solution segments

jabba.seg.rds --- GRanges rds with jabba.simple solution segments

jabba.adj.txt --- tsv file with edges (i.e. node pairs) of adjacency matrix populated with inferred copy numbers and node ids indexing segments in jabba.seg.txt

jabba.vcf, jabba.simple.vcf --- BND-style vcf output of junctions in JaBbA output populated with rearrangement and interval copy numbers

jabba.cnv.vcf, jabba.simple.cnv.vcf --- cfopy number style VCF showing jabba copy number output
}
\examples{

library(jabbadevtest)
junctions = system.file("extdata", "junctions.vcf", package = 'jabbadevtest')
coverage = system.file("extdata", "coverage.txt", package = 'jabbadevtest')
hets = system.file("extdata", "hets.txt", package = 'jabbadevtest')

## run analysis without hets 
jab = JaBbA(junctions = junctions, coverage = coverage)

## run analysis with hets in different subdir (default ./JaBbA)
jab = JaBbA(junctions = junctions, coverage = coverage, hets = hets, outdir = './mydir')

## run analysis with "tiered" junctions, these have metadata field $tier (in this case inside the vcf)
jun = read.junctions(junctions)

## these have metadata field tier, tier 1 junctions are forced to be included, tier 2 = are optional i.e. can be included,
## tier 3 are only used in later iterations to rescue loose ends
values(jun)$tier

## here we will iterate JaBbA max 4 times, or until we run out of tier three junctions near loose ends
jab = JaBbA(junctions = jun, coverage = coverage, hets = hets, reiterate = 4, outdir = './iter')

## can increase the window to rescue more junctions within 100kb of loose ends,
## will overwrite original ./JaBbA outdir with overwrite = TRUE
jab = JaBbA(junctions = jun, coverage = coverage, hets = hets, reiterate = 4, rescue.window = 1e5, overwrite = TRUE)

}
